"use strict";

var _steps = require("cypress-cucumber-preprocessor/steps");

var _parseSelectorWithDataTest = require("../../../../../cypress/support/common/parseSelectorWithDataTest");

var _common = require("../common");

(0, _steps.Given)('some options are selectable', () => {
  cy.visitStory('Transfer Transferring Items', 'Has Options');
});
(0, _steps.Given)('some options are selected', () => {
  cy.visitStory('Transfer Transferring Items', 'Some Selected');
});
(0, _steps.Given)('one or more items in the options list are highlighted', () => {
  cy.get('{transfer-sourceoptions} {transferoption}').filter(index => index < 3) // shuffle order so we can check they're added in the right order
  .then($options => cy.wrap([$options[2], $options[0], $options[1]])).each($option => cy.wrap($option).clickWith('ctrl')).then($options => $options.toArray().map(_common.extractOptionFromElement)).as('itemsToBeSelected');
});
(0, _steps.Given)('some items in the options list are highlighted', () => {
  cy.get('{transfer-sourceoptions} {transferoption}').filter(index => index < 3) // shuffle order so we can check they're added in the right order
  .then($options => cy.wrap([$options[2], $options[0], $options[1]])).each($option => cy.wrap($option).clickWith('ctrl')).then($options => $options.toArray().map(_common.extractOptionFromElement)).as('itemsToBeSelected');
});
(0, _steps.Given)('some items in the selected list are highlighted', () => {
  cy.get('{transfer-pickedoptions} {transferoption}').filter(index => index < 3) // shuffle order so we can check they're added in the right order
  .then($options => cy.wrap([$options[2], $options[0], $options[1]])).each($option => cy.wrap($option).clickWith('ctrl')).then($options => $options.toArray().map(_common.extractOptionFromElement)).as('itemsToBeDeselected');
});
(0, _steps.When)("the user clicks the 'move to selected list' button", () => {
  cy.get('{transfer-actions-addindividual}').click();
});
(0, _steps.When)("the user clicks the 'move to options list' button", () => {
  cy.get('{transfer-actions-removeindividual}').click();
});
(0, _steps.When)("the user clicks the 'move all to selected list' button", () => {
  cy.get('{transfer-sourceoptions} {transferoption}').then($options => $options.toArray().map(_common.extractOptionFromElement)).as('itemsToBeSelected');
  cy.get('{transfer-actions-addall}').click();
});
(0, _steps.When)("the user clicks the 'move all to options list' button", () => {
  cy.get('{transfer-pickedoptions} {transferoption}').then($options => $options.toArray().map(_common.extractOptionFromElement)).as('itemsToBeDeselected');
  cy.get('{transfer-actions-removeall}').click();
});
(0, _steps.When)('the user double clicks an item in the options list', () => {
  cy.get('{transfer-sourceoptions} {transferoption}').first().dblclick().then(_common.extractOptionFromElement).as('doubleClickedPlainOption');
});
(0, _steps.When)('the user double clicks an item in the selected list', () => {
  cy.get('{transfer-pickedoptions} {transferoption}').first().dblclick().then(_common.extractOptionFromElement).as('doubleClickedPlainOption');
});
(0, _steps.Then)('the highlighted items should be removed from the options list', () => {
  cy.all(() => cy.get('@itemsToBeSelected'), () => cy.get('{transfer-sourceoptions} {transferoption}')).should(([itemsToBeSelected, $selectableSourceOptions]) => {
    const selectableSourceOptions = $selectableSourceOptions.toArray().map(_common.extractOptionFromElement);
    const itemsStillSelectable = itemsToBeSelected.every(itemToBeSelected => {
      const result = selectableSourceOptions.find(({
        label,
        value
      }) => label === itemToBeSelected.label && value === itemToBeSelected.value);
      return result;
    });
    expect(itemsStillSelectable).to.equal(false);
  });
});
(0, _steps.Then)('the highlighted items should be visible in the selected list', () => {
  cy.all(() => cy.get('@itemsToBeSelected'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([itemsToBeSelected, $selectedOptions]) => {
    const selectedOptions = $selectedOptions.toArray().map(_common.extractOptionFromElement);
    const itemsSelected = itemsToBeSelected.every(itemToBeSelected => selectedOptions.find(({
      label,
      value
    }) => label === itemToBeSelected.label && value === itemToBeSelected.value));
    expect(itemsSelected).to.equal(true);
  });
});
(0, _steps.Then)('the highlighted items should be appended to the selected list in the order they were highlighted', () => {
  cy.all(() => cy.get('@itemsToBeSelected'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([itemsToBeSelected, $selectedOptions]) => {
    const lastNSelectedOptions = $selectedOptions.toArray().map(_common.extractOptionFromElement).slice(itemsToBeSelected.length * -1);
    expect(itemsToBeSelected).to.eql(lastNSelectedOptions);
  });
});
(0, _steps.Then)('the highlighted items should be removed from the selected list', () => {
  cy.all(() => cy.get('@itemsToBeDeselected'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([itemsToBeDeselected, $selectedOptions]) => {
    const selectedOptions = $selectedOptions.toArray().map(_common.extractOptionFromElement);
    const itemsStillSelected = itemsToBeDeselected.every(itemToBeSelected => {
      const result = selectedOptions.find(({
        label,
        value
      }) => label === itemToBeSelected.label && value === itemToBeSelected.value);
      return result;
    });
    expect(itemsStillSelected).to.equal(false);
  });
});
(0, _steps.Then)('the highlighted items should be visible in the options list', () => {
  cy.all(() => cy.get('@itemsToBeDeselected'), () => cy.get('{transfer-sourceoptions} {transferoption}')).should(([itemsToBeDeselected, $selectedOptions]) => {
    const selectedOptions = $selectedOptions.toArray().map(_common.extractOptionFromElement);
    const itemsSelectable = itemsToBeDeselected.every(itemToBeSelected => {
      const result = selectedOptions.find(({
        label,
        value
      }) => label === itemToBeSelected.label && value === itemToBeSelected.value);
      return result;
    });
    expect(itemsSelectable).to.equal(true);
  });
});
(0, _steps.Then)('the highlighted items should be in the original options list ordering', () => {
  cy.all(() => cy.window(), () => cy.get('{transfer-sourceoptions} {transferoption}'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([win, $selectableSourceOptions, $selectedOptions]) => {
    const selectedOptions = $selectedOptions.toArray().map(_common.extractOptionFromElement);
    const selectableSourceOptions = $selectableSourceOptions.toArray().map(_common.extractOptionFromElement);
    const allOptionsWithoutSelected = win.options.filter(option => {
      return !selectedOptions.find(({
        label,
        value
      }) => option.label === label && option.value === value);
    });
    expect(allOptionsWithoutSelected).to.eql(selectableSourceOptions);
  });
});
(0, _steps.Then)('all items should be removed from the options list', () => {
  cy.get('{transfer-sourceoptions} {transferoption}').should('not.exist');
});
(0, _steps.Then)('all items removed from options list should be visible in the selected list', () => {
  cy.all(() => cy.get('@itemsToBeSelected'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([itemsToBeSelected, $selectedOptions]) => {
    const selectedOptions = $selectedOptions.toArray().map(_common.extractOptionFromElement);
    const allSelected = itemsToBeSelected.every(option => {
      return selectedOptions.find(({
        label,
        value
      }) => option.label === label && option.value === value);
    });
    expect(allSelected).to.equal(true);
  });
});
(0, _steps.Then)('the transferred items should be appended to the selected list in the order they were displayed in the options list', () => {
  cy.all(() => cy.get('@itemsToBeSelected'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([itemsToBeSelected, $selectedOptions]) => {
    const selectedOptions = $selectedOptions.toArray().map(_common.extractOptionFromElement);
    const previouslySelectedSubset = selectedOptions.slice(-1 * itemsToBeSelected.length);
    expect(itemsToBeSelected).to.eql(previouslySelectedSubset);
  });
});
(0, _steps.Then)('all items should be removed from the selected list', () => {
  cy.get('{transfer-pickedoptions} {transferoption}').should('not.exist');
});
(0, _steps.Then)('all items removed from selected list should be visible in the options list', () => {
  cy.all(() => cy.get('@itemsToBeDeselected'), () => cy.get('{transfer-sourceoptions} {transferoption}')).should(([itemsToBeDeselected, $selectableSourceOptions]) => {
    const selectableSourceOptions = $selectableSourceOptions.toArray().map(_common.extractOptionFromElement);
    const allSelectable = itemsToBeDeselected.every(option => {
      return selectableSourceOptions.find(({
        label,
        value
      }) => option.label === label && option.value === value);
    });
    expect(allSelectable).to.equal(true);
  });
});
(0, _steps.Then)('the transferred items should be appended to the selected list in the order they were displayed in the options list', () => {
  cy.all(() => cy.get('@itemsToBeSelected'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([itemsToBeSelected, $selectedOptions]) => {
    const selectedOptions = $selectedOptions.toArray().map(_common.extractOptionFromElement);
    const previouslySelectedSubset = selectedOptions.slice(-1 * itemsToBeSelected.length);
    expect(itemsToBeSelected).to.eql(previouslySelectedSubset);
  });
});
(0, _steps.Then)('the options list items should be ordered in the original order', () => {
  cy.all(() => cy.window(), () => cy.get('{transfer-sourceoptions} {transferoption}'), () => cy.get('{transfer-pickedoptions}').then($pickedOptions => {
    return $pickedOptions.find((0, _parseSelectorWithDataTest.parseSelectorWithDataTest)('{transferoption}'));
  })).should(([win, $selectableSourceOptions, $pickedOptions]) => {
    const pickedPlainOptions = $pickedOptions.toArray().map(_common.extractOptionFromElement);
    const originalOrderWithoutSelected = win.options.filter(originalOption => {
      return !pickedPlainOptions.find(pickedPlainOption => pickedPlainOption.value === originalOption.value && pickedPlainOption.label === originalOption.label);
    });
    const selectableSourceOptions = $selectableSourceOptions.toArray().map(_common.extractOptionFromElement);
    expect(originalOrderWithoutSelected).to.eql(selectableSourceOptions);
  });
});
(0, _steps.Then)('the item should be removed from its options list', () => {
  cy.all(() => cy.get('@doubleClickedPlainOption'), () => cy.get('{transfer-sourceoptions} {transferoption}')).should(([doubleClickedPlainOption, $sourceOptions]) => {
    const sourcePlainOptions = $sourceOptions.toArray().map(_common.extractOptionFromElement);
    const found = sourcePlainOptions.find(sourcePlainOption => sourcePlainOption.value === doubleClickedPlainOption.value && sourcePlainOption.label === doubleClickedPlainOption.label);
    expect(found).to.not.equal(true);
  });
});
(0, _steps.Then)('the item should be visible at the bottom of the selected list', () => {
  cy.all(() => cy.get('@doubleClickedPlainOption'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([doubleClickedPlainOption, $pickedOptions]) => {
    const lastSourcePlainOption = $pickedOptions.last().toArray().map(_common.extractOptionFromElement).pop();
    const doubleClickedOptionIsLast = lastSourcePlainOption.value === doubleClickedPlainOption.value && lastSourcePlainOption.label === doubleClickedPlainOption.label;
    expect(doubleClickedOptionIsLast).to.equal(true);
  });
});
(0, _steps.Then)('the item should be removed from the selected list', () => {
  cy.all(() => cy.get('@doubleClickedPlainOption'), () => cy.get('{transfer-pickedoptions} {transferoption}')).should(([doubleClickedPlainOption, $pickedOptions]) => {
    const pickedPlainOptions = $pickedOptions.toArray().map(_common.extractOptionFromElement);
    const found = pickedPlainOptions.find(sourcePlainOption => sourcePlainOption.value === doubleClickedPlainOption.value && sourcePlainOption.label === doubleClickedPlainOption.label);
    expect(found).to.not.equal(true);
  });
});