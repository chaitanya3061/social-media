import { render, waitFor, act } from '@testing-library/react';
import React from 'react';
import { CustomDataProvider, DataQuery } from '../react';
const customData = {
  answer: 42
};
describe('Testing custom data provider and useQuery hook', () => {
  it('Should render without failing', async () => {
    const renderFunction = jest.fn(({
      loading,
      error,
      data
    }) => {
      if (loading) return 'loading';
      if (error) return /*#__PURE__*/React.createElement("div", null, "error: ", error.message);
      return /*#__PURE__*/React.createElement("div", null, "data: ", data && data.answer);
    });
    const {
      getByText
    } = render( /*#__PURE__*/React.createElement(CustomDataProvider, {
      data: customData
    }, /*#__PURE__*/React.createElement(DataQuery, {
      query: {
        answer: {
          resource: 'answer'
        }
      }
    }, renderFunction)));
    expect(getByText(/loading/i)).not.toBeUndefined();
    expect(renderFunction).toHaveBeenCalledTimes(1);
    expect(renderFunction).toHaveBeenLastCalledWith({
      called: true,
      loading: true,
      refetch: expect.any(Function),
      engine: expect.any(Object)
    });
    await waitFor(() => getByText(/data: /i));
    expect(renderFunction).toHaveBeenCalledTimes(2);
    expect(renderFunction).toHaveBeenLastCalledWith({
      called: true,
      loading: false,
      data: customData,
      refetch: expect.any(Function),
      engine: expect.any(Object)
    });
    expect(getByText(/data: /i)).toHaveTextContent("data: ".concat(customData.answer));
  });
  it('Should render an error', async () => {
    const renderFunction = jest.fn(({
      loading,
      error,
      data
    }) => {
      if (loading) return 'loading';
      if (error) return /*#__PURE__*/React.createElement("div", null, "error: ", error.message);
      return /*#__PURE__*/React.createElement("div", null, "data: ", data && data.test);
    });
    const {
      getByText
    } = render( /*#__PURE__*/React.createElement(CustomDataProvider, {
      data: customData
    }, /*#__PURE__*/React.createElement(DataQuery, {
      query: {
        test: {
          resource: 'test'
        }
      }
    }, renderFunction)));
    expect(getByText(/loading/i)).not.toBeUndefined();
    expect(renderFunction).toHaveBeenCalledTimes(1);
    expect(renderFunction).toHaveBeenLastCalledWith({
      called: true,
      loading: true,
      refetch: expect.any(Function),
      engine: expect.any(Object)
    });
    await waitFor(() => getByText(/error: /i));
    expect(renderFunction).toHaveBeenCalledTimes(2);
    expect(String(renderFunction.mock.calls[1][0].error)).toBe('Error: No data provided for resource type test!'); // expect(getByText(/data: /i)).toHaveTextContent(
    //     `data: ${customData.answer}`
    // )
  });
  it('Should abort the fetch when unmounted', async () => {
    const renderFunction = jest.fn(({
      loading,
      error,
      data
    }) => {
      if (loading) return 'loading';
      if (error) return /*#__PURE__*/React.createElement("div", null, "error: ", error.message);
      return /*#__PURE__*/React.createElement("div", null, "data: ", data && data.test);
    });
    let signal;
    const mockData = {
      factory: jest.fn(async (type, _, options) => {
        if (options && options.signal && !signal) {
          signal = options.signal;
        }

        return 'done';
      })
    };
    const {
      unmount
    } = render( /*#__PURE__*/React.createElement(CustomDataProvider, {
      data: mockData
    }, /*#__PURE__*/React.createElement(DataQuery, {
      query: {
        test: {
          resource: 'factory'
        }
      }
    }, renderFunction)));
    expect(renderFunction).toHaveBeenCalledTimes(1);
    expect(mockData.factory).toHaveBeenCalledTimes(1);
    act(() => {
      unmount();
    });
    expect(signal && signal.aborted).toBe(true);
  });
  it('Should abort the fetch when refetching', async () => {
    let refetch;
    const renderFunction = jest.fn(({
      loading,
      error,
      data,
      refetch: _refetch
    }) => {
      refetch = _refetch;
      if (loading) return 'loading';
      if (error) return /*#__PURE__*/React.createElement("div", null, "error: ", error.message);
      return /*#__PURE__*/React.createElement("div", null, "data: ", data && data.test);
    });
    let signal;
    const mockData = {
      factory: jest.fn(async (type, q, options) => {
        if (options && options.signal && !signal) {
          signal = options.signal;
        }

        return 'test';
      })
    };
    const {
      getByText
    } = render( /*#__PURE__*/React.createElement(CustomDataProvider, {
      data: mockData
    }, /*#__PURE__*/React.createElement(DataQuery, {
      query: {
        test: {
          resource: 'factory'
        }
      }
    }, renderFunction)));
    expect(renderFunction).toHaveBeenCalledTimes(1);
    expect(mockData.factory).toHaveBeenCalledTimes(1);
    expect(signal.aborted).toBe(false);
    expect(refetch).not.toBeUndefined();
    act(() => {
      refetch();
    });
    expect(signal.aborted).toBe(true);
    await waitFor(() => getByText(/data: /i));
    expect(renderFunction).toHaveBeenCalledTimes(2);
    expect(mockData.factory).toHaveBeenCalledTimes(2);
  });
});